"""
OrQuanta Agentic v1.0 â€” One-Click Startup Script

Usage:
    python start_orquanta.py [--no-browser] [--prod] [--skip-checks]

What it does:
  1. Check prerequisites (Python, Docker, Node.js)
  2. Validate .env file has required keys
  3. Start Docker Compose services in order
  4. Wait for health checks (Postgres, Redis, API)
  5. Run database migrations automatically
  6. Start frontend dev server
  7. Open browser to dashboard
  8. Display live URLs and admin credentials

All in a beautiful terminal UI with progress bars.
"""

import argparse
import json
import os
import platform
import shutil
import subprocess
import sys
import time
import webbrowser
from pathlib import Path

# â”€â”€â”€ Terminal colors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class C:
    R = "\033[0m"
    BOLD = "\033[1m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    RED = "\033[91m"
    CYAN = "\033[96m"
    BLUE = "\033[94m"
    MAGENTA = "\033[95m"
    DIM = "\033[2m"

def ok(msg): print(f"  {C.GREEN}âœ“{C.R} {msg}")
def warn(msg): print(f"  {C.YELLOW}âš {C.R} {msg}")
def err(msg): print(f"  {C.RED}âœ—{C.R} {msg}")
def info(msg): print(f"  {C.CYAN}â†’{C.R} {msg}")
def step(msg): print(f"\n{C.BOLD}{C.BLUE}[{msg}]{C.R}")
def banner():
    print(f"""
{C.BOLD}{C.MAGENTA}
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘          OrQuanta Agentic v1.0 Platform             â•‘
  â•‘     AI-Native GPU Cloud Infrastructure           â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{C.R}""")

# â”€â”€â”€ Project paths â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PROJECT_ROOT = Path(__file__).parent
V4_DIR = PROJECT_ROOT / "v4"
INFRA_DIR = V4_DIR / "infra"
FRONTEND_DIR = V4_DIR / "frontend"
ENV_FILE = PROJECT_ROOT / "v4" / ".env"
ENV_EXAMPLE = PROJECT_ROOT / "v4" / ".env.example"

REQUIRED_ENV_VARS = [
    # These MUST be set for a working local dev environment
    "DATABASE_URL",
    "REDIS_URL",
    "JWT_SECRET_KEY",
]
OPTIONAL_ENV_VARS = [
    "OPENAI_API_KEY",
    "ANTHROPIC_API_KEY",
    "AWS_ACCESS_KEY_ID",
    "GCP_PROJECT_ID",
    "AZURE_SUBSCRIPTION_ID",
    "COREWEAVE_API_KEY",
    "SLACK_WEBHOOK_URL",
    "SENDGRID_API_KEY",
]

# â”€â”€â”€ Default .env content for local dev â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DEFAULT_ENV = """# OrQuanta Agentic v1.0 â€” Local Development Environment
# Auto-generated by start_orquanta.py â€” edit as needed

# â”€â”€ Core â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
DATABASE_URL=postgresql+asyncpg://orquanta:orquanta@localhost:5432/orquanta
REDIS_URL=redis://localhost:6379/0
JWT_SECRET_KEY=orquanta-local-dev-secret-change-in-prod-{random}
JWT_ALGORITHM=HS256
JWT_EXPIRE_MINUTES=720

# â”€â”€ LLM Providers (optional â€” mocks work without keys) â”€â”€â”€â”€â”€â”€â”€â”€â”€
LLM_PROVIDER=mock
OPENAI_API_KEY=
ANTHROPIC_API_KEY=

# â”€â”€ Cloud Providers (optional â€” simulated without keys) â”€â”€â”€â”€â”€â”€â”€â”€
USE_REAL_PROVIDERS=false
AWS_ACCESS_KEY_ID=
AWS_SECRET_ACCESS_KEY=
AWS_DEFAULT_REGION=us-east-1
GCP_PROJECT_ID=
GOOGLE_APPLICATION_CREDENTIALS=
AZURE_SUBSCRIPTION_ID=
AZURE_CLIENT_ID=
AZURE_CLIENT_SECRET=
AZURE_TENANT_ID=
COREWEAVE_API_KEY=

# â”€â”€ Safety â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SAFETY_MAX_DAILY_SPEND_USD=5000
SAFETY_MAX_CONCURRENT_AGENTS=5
SAFETY_RATE_LIMIT_PER_MINUTE=60

# â”€â”€ Monitoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
SLACK_WEBHOOK_URL=
SENDGRID_API_KEY=
PAGERDUTY_ROUTING_KEY=
ALERT_EMAIL_FROM=alerts@orquanta.ai
ALERT_EMAIL_TO=ops@orquanta.ai

# â”€â”€ Frontend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
VITE_API_BASE_URL=http://localhost:8000
VITE_WS_BASE_URL=ws://localhost:8000

# â”€â”€ CORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CORS_ORIGINS=http://localhost:3000,http://localhost:5173
"""


# â”€â”€â”€ Prerequisite checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def check_python():
    v = sys.version_info
    if v.major < 3 or (v.major == 3 and v.minor < 10):
        err(f"Python 3.10+ required (got {v.major}.{v.minor})")
        return False
    ok(f"Python {v.major}.{v.minor}.{v.micro}")
    return True


def check_docker():
    docker = shutil.which("docker")
    if not docker:
        err("Docker not found. Install from https://docker.com")
        return False
    try:
        result = subprocess.run(["docker", "info"], capture_output=True, text=True, timeout=5)
        if result.returncode != 0:
            err("Docker daemon is not running. Start Docker Desktop first.")
            return False
        ok("Docker daemon running")
        return True
    except Exception as e:
        err(f"Docker check failed: {e}")
        return False


def check_docker_compose():
    for cmd in [["docker", "compose", "version"], ["docker-compose", "--version"]]:
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                ver = result.stdout.strip().split()[-1]
                ok(f"Docker Compose {ver}")
                return True
        except Exception:
            continue
    err("Docker Compose not found. Update Docker Desktop or install docker-compose.")
    return False


def check_nodejs(frontend_only: bool = True):
    node = shutil.which("node")
    npm = shutil.which("npm")
    if not node or not npm:
        warn("Node.js / npm not found â€” frontend dev server won't start")
        warn("Install from https://nodejs.org (v18+)")
        return False
    try:
        ver = subprocess.run(["node", "--version"], capture_output=True, text=True).stdout.strip()
        ok(f"Node.js {ver}")
        return True
    except Exception:
        return False


def check_required_packages():
    """Check Python packages are installed."""
    missing = []
    for pkg in ["fastapi", "uvicorn", "sqlalchemy", "httpx"]:
        try:
            __import__(pkg)
        except ImportError:
            missing.append(pkg)
    if missing:
        warn(f"Missing Python packages: {', '.join(missing)}")
        warn("Run: pip install -r v4/requirements.txt")
        return False
    ok("Python packages installed")
    return True


# â”€â”€â”€ .env management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def setup_env():
    """Create .env from template if it doesn't exist."""
    if not ENV_FILE.exists():
        warn(".env not found â€” creating from defaults")
        import secrets
        content = DEFAULT_ENV.replace("{random}", secrets.token_hex(16))
        ENV_FILE.write_text(content)
        ok(f"Created {ENV_FILE}")
        info("âš¡ Edit v4/.env to add real API keys for cloud providers")
    else:
        ok(f".env exists at {ENV_FILE}")


def validate_env() -> dict[str, str]:
    """Load and validate environment variables."""
    env = {}
    if ENV_FILE.exists():
        for line in ENV_FILE.read_text().splitlines():
            line = line.strip()
            if line and not line.startswith("#") and "=" in line:
                k, _, v = line.partition("=")
                env[k.strip()] = v.strip()

    missing_required = []
    for var in REQUIRED_ENV_VARS:
        val = env.get(var) or os.getenv(var, "")
        if not val:
            missing_required.append(var)

    if missing_required:
        err(f"Required .env vars missing: {', '.join(missing_required)}")
        return {}

    configured_optional = [v for v in OPTIONAL_ENV_VARS if env.get(v) or os.getenv(v)]
    ok(f"Required env vars present ({len(configured_optional)}/{len(OPTIONAL_ENV_VARS)} optional configured)")
    return env


# â”€â”€â”€ Docker Compose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def get_compose_cmd():
    """Return the appropriate docker compose command."""
    result = subprocess.run(["docker", "compose", "version"], capture_output=True, timeout=5)
    if result.returncode == 0:
        return ["docker", "compose"]
    return ["docker-compose"]


def start_services(compose_cmd: list[str], prod: bool = False):
    """Start Docker Compose services."""
    compose_file = INFRA_DIR / "docker-compose.yml"
    if not compose_file.exists():
        compose_file = PROJECT_ROOT / "docker-compose.yml"

    cmd = compose_cmd + ["-f", str(compose_file), "up", "-d"]

    # Start required infrastructure first (not frontend / API)
    infra_services = ["postgres", "redis", "chromadb"]
    info(f"Starting infrastructure services: {', '.join(infra_services)}")

    infra_cmd = cmd + infra_services
    result = subprocess.run(infra_cmd, capture_output=True, text=True, timeout=120)
    if result.returncode != 0:
        warn(f"Infrastructure services: {result.stderr[:200]}")
    else:
        ok("Infrastructure services started")

    # Now start API + Celery
    api_services = ["api", "celery_worker"]
    if not prod:
        api_services = ["api"]  # Skip celery in dev
    info("Starting API serviceâ€¦")
    api_cmd = cmd + ["api"]
    subprocess.run(api_cmd, capture_output=True, text=True, timeout=120)


def wait_for_service(url: str, service_name: str, timeout_s: int = 120) -> bool:
    """Poll a health check URL until it responds."""
    import urllib.request, urllib.error
    deadline = time.time() + timeout_s
    dot_count = 0

    print(f"  {C.CYAN}â†’{C.R} Waiting for {service_name}", end="", flush=True)
    while time.time() < deadline:
        try:
            urllib.request.urlopen(url, timeout=3)
            print(f" {C.GREEN}ready!{C.R}")
            return True
        except Exception:
            print(".", end="", flush=True)
            dot_count += 1
            if dot_count % 30 == 0:
                print()
            time.sleep(2)

    print(f" {C.RED}timeout!{C.R}")
    return False


def run_migrations():
    """Apply database schema via psql or alembic."""
    sql_file = V4_DIR / "database" / "migrations" / "001_initial.sql"
    if not sql_file.exists():
        warn("Migration file not found â€” skipping")
        return False

    # Try alembic first, then plain psql
    alembic = shutil.which("alembic")
    if alembic:
        result = subprocess.run(
            [alembic, "upgrade", "head"],
            cwd=str(V4_DIR), capture_output=True, text=True, timeout=30
        )
        if result.returncode == 0:
            ok("Database migrations applied (Alembic)")
            return True

    psql = shutil.which("psql")
    if psql:
        db_url = os.getenv("DATABASE_URL", "postgresql://orquanta:orquanta@localhost:5432/orquanta")
        db_url = db_url.replace("postgresql+asyncpg://", "postgresql://")
        result = subprocess.run(
            [psql, db_url, "-f", str(sql_file)],
            capture_output=True, text=True, timeout=30
        )
        if result.returncode == 0:
            ok("Database migrations applied (psql)")
            return True
        else:
            warn(f"Migration via psql failed: {result.stderr[:100]}")

    warn("Skipped database migrations (no psql/alembic available in PATH)")
    info("To migrate manually: psql $DATABASE_URL -f v4/database/migrations/001_initial.sql")
    return False


def start_api_direct():
    """Start the FastAPI server directly (for non-Docker dev mode)."""
    cmd = [
        sys.executable, "-m", "uvicorn",
        "v4.api.main:app",
        "--host", "0.0.0.0",
        "--port", "8000",
        "--reload",
    ]
    info("Starting API server (uvicorn --reload)â€¦")
    proc = subprocess.Popen(
        cmd,
        cwd=str(PROJECT_ROOT),
        env={**os.environ, **_load_env_file()},
    )
    return proc


def start_frontend():
    """Start the Vite dev server."""
    if not FRONTEND_DIR.exists():
        warn("Frontend directory not found â€” skipping")
        return None

    node_modules = FRONTEND_DIR / "node_modules"
    if not node_modules.exists():
        info("Installing frontend dependencies (npm install)â€¦")
        subprocess.run(["npm", "install"], cwd=str(FRONTEND_DIR), timeout=120)
        ok("Frontend dependencies installed")

    info("Starting Vite dev serverâ€¦")
    proc = subprocess.Popen(
        ["npm", "run", "dev"],
        cwd=str(FRONTEND_DIR),
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    return proc


def _load_env_file() -> dict[str, str]:
    """Load key=value pairs from .env file."""
    env = {}
    if ENV_FILE.exists():
        for line in ENV_FILE.read_text().splitlines():
            line = line.strip()
            if line and not line.startswith("#") and "=" in line:
                k, _, v = line.partition("=")
                env[k.strip()] = v.strip()
    return env


# â”€â”€â”€ Final summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def print_summary(use_docker: bool = True):
    api_url = "http://localhost:8000"
    frontend_url = "http://localhost:3000"
    grafana_url = "http://localhost:3001"
    docs_url = f"{api_url}/docs"

    print(f"""
{C.BOLD}{C.GREEN}
  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
  â•‘          ğŸš€ OrQuanta Agentic v1.0 LIVE!            â•‘
  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{C.R}
  {C.BOLD}Dashboard:{C.R}   {C.CYAN}{frontend_url}{C.R}
  {C.BOLD}API:{C.R}         {C.CYAN}{api_url}{C.R}
  {C.BOLD}API Docs:{C.R}    {C.CYAN}{docs_url}{C.R}""")

    if use_docker:
        print(f"  {C.BOLD}Grafana:{C.R}     {C.CYAN}{grafana_url}{C.R} (admin/admin)")

    print(f"""
  {C.BOLD}Default credentials:{C.R}
    Email:    admin@orquanta.ai
    Password: orquanta-admin-2024

  {C.DIM}All 80 tests: python -m pytest v4/tests/ -v{C.R}
  {C.DIM}Stop:         Ctrl+C  (or docker compose down){C.R}
""")


# â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def main():
    parser = argparse.ArgumentParser(description="OrQuanta Agentic v1.0 Startup Script")
    parser.add_argument("--no-browser", action="store_true", help="Don't open browser")
    parser.add_argument("--prod", action="store_true", help="Production Docker mode")
    parser.add_argument("--skip-checks", action="store_true", help="Skip prerequisite checks")
    parser.add_argument("--no-docker", action="store_true", help="Start API directly without Docker")
    args = parser.parse_args()

    # Enable ANSI colors on Windows
    if platform.system() == "Windows":
        os.system("color")

    banner()

    # â”€â”€ Step 1: Check prerequisites â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    step("1/7 â€” Checking Prerequisites")
    checks_ok = True
    if not args.skip_checks:
        checks_ok = all([
            check_python(),
            check_required_packages(),
            check_docker() if not args.no_docker else True,
            check_docker_compose() if not args.no_docker else True,
            check_nodejs(),
        ])
    if not checks_ok:
        warn("Some prerequisites failed â€” continuing anyway (may encounter errors)")

    # â”€â”€ Step 2: Environment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    step("2/7 â€” Environment Configuration")
    setup_env()
    env = validate_env()
    if not env and not args.skip_checks:
        err("Environment validation failed. Edit v4/.env and retry.")
        sys.exit(1)

    # Load env vars into process
    for k, v in _load_env_file().items():
        os.environ.setdefault(k, v)

    procs = []

    if args.no_docker:
        # â”€â”€ Step 3: Direct mode (no Docker) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        step("3/7 â€” Starting API Server Directly")
        api_proc = start_api_direct()
        procs.append(("API", api_proc))

        step("4/7 â€” Waiting for APIâ€¦")
        if not wait_for_service("http://localhost:8000/health", "API", timeout_s=30):
            warn("API might still be starting up")

        step("5/7 â€” Running Database Migrations")
        run_migrations()

    else:
        # â”€â”€ Step 3: Docker Compose â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        step("3/7 â€” Starting Docker Infrastructure")
        compose_cmd = get_compose_cmd()
        start_services(compose_cmd, prod=args.prod)

        step("4/7 â€” Waiting for Services to be Healthy")
        db_ok = wait_for_service("http://localhost:8000/health", "API (Docker)", timeout_s=90)
        if not db_ok:
            warn("API health check did not pass â€” check logs: docker compose logs api")

        step("5/7 â€” Running Database Migrations")
        run_migrations()

    # â”€â”€ Step 6: Frontend â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    step("6/7 â€” Starting Frontend Dev Server")
    frontend_proc = start_frontend()
    if frontend_proc:
        procs.append(("Frontend", frontend_proc))
        time.sleep(3)

    # â”€â”€ Step 7: Open browser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    step("7/7 â€” Launching Dashboard")
    if not args.no_browser:
        try:
            time.sleep(2)
            webbrowser.open("http://localhost:3000")
            ok("Opened http://localhost:3000 in browser")
        except Exception:
            info("Open http://localhost:3000 in your browser")

    print_summary(use_docker=not args.no_docker)

    # Keep running, print process output
    if procs:
        info(f"Running {len(procs)} processes â€” Ctrl+C to stop all")
        try:
            while True:
                time.sleep(1)
                for name, proc in procs:
                    if proc.poll() is not None:
                        warn(f"{name} process exited with code {proc.returncode}")
        except KeyboardInterrupt:
            print(f"\n{C.YELLOW}Shutting downâ€¦{C.R}")
            for name, proc in procs:
                proc.terminate()
                info(f"Stopped {name}")
            print(f"{C.GREEN}See you! ğŸ‘‹{C.R}\n")


if __name__ == "__main__":
    main()
